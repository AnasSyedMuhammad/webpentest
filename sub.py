
import re
import sys


import urllib.parse as urlparse
import argparse
import urllib.parse as urllib
import time




import requests.packages.urllib3





import multiprocessing
import threading
import socket


def sort_sub(domain_name):  
    sorted = domain_name.split('.')[::-1]
    if sorted[-1] == 'www':
        return sorted[:-1], 1
    return sorted, 0


class sub(object):
    def __init__(self, base_url, search_engine, domain, subdomains=None):  
        subdomains = subdomains or []
        self.domain = urlparse.urlparse(domain).netloc
        self.session = requests.Session()
        self.subdomains = []
        self.timeout = 25
        self.base_url = base_url
        self.search_engine = search_engine
        self.headers = {
            
        }
        self.print_banner()

    

    def request(self, query, pg_num=1):

        parsed_url = self.base_url.format(query=query, page_no=pg_num)
        try:
            response = self.session.get(parsed_url, headers=self.headers, timeout=self.timeout)
        except Exception:
            response = None
        return self.resp(response)

    def resp(self, response):
        if response is None:
            return 0
        return response.text if hasattr(response, "text") else response.content


class tthread(multiprocessing.Process, sub):
    def __init__(self, base_url, search_engine, domain, subdomains=None, q=None):
        subdomains = subdomains or []
        sub.__init__(self, base_url, search_engine, domain, subdomains)
        multiprocessing.Process.__init__(self)
        self.q = q
        return

    def run(self):
        domain_list = self.enumerate()
        for domain in domain_list:
            self.q.append(domain)


class engine_crt_ssl(tthread):
    def __init__(self, domain, subdomains=None, q=None):
        subdomains = subdomains or []
        base_url = 'https://crt.sh/?q=%25.{domain}'
        self.search_engine = "SSL Certificates"
        self.q = q
        super(engine_crt_ssl, self).__init__(base_url, self.search_engine, domain, subdomains, q=q)
        return

    def req(self, url):
        try:
            resp = self.session.get(url, headers=self.headers, timeout=self.timeout)
        except Exception:
            resp = None

        return self.resp(resp)

    
    def find_domin_rgx(self, resp):
        rgx = re.compile('<TD>(*?)</TD>')
        try:
            links = rgx.findall(resp)
            for link in links:
                link = link.strip()
                subdomains = []
                if '<BR>' in link:
                    subdomains = link.split('<BR>')
                else:
                    subdomains.append(link)

                for subdomain in subdomains:
                    if not subdomain.endswith(self.domain) or '*' in subdomain:
                        continue

                    if subdomain not in self.subdomains and subdomain != self.domain:
                        self.subdomains.append(subdomain.strip())
        except Exception as e:
            print(e)
            pass


def main(parsed_host):  
    s_domainLen=None
    search_list = set()
    sub_inline = multiprocessing.Manager().list()
    inspect_dom = re.compile("^(https|http)?+(.[\-\\.]{1}[a-zA--9]+)*\.[a-zA-\..\Z]{2,}$")
    if not inspect_dom.match(parsed_host):
        return ["Error: Not a valid host name, enter a valid host name"]

    if not parsed_host.startswith('http://') or not parsed_host.startswith('https://'):
        parsed_host = 'http://' + parsed_host

    domin_entered = urlparse.urlparse(parsed_host)

    print("searching  sub domains for %s" % domin_entered.netloc)

    find="searching sub domains for %s" % domin_entered.netloc


    supported_engines = {'ssl': engine_crt_ssl}

    selected_enm = []

    selected_enm = [
        engine_crt_ssl
    ]

    en = [enum(parsed_host, [], q=sub_inline) for enum in selected_enm]
    for enum in en:
        enum.start()
    for enum in en:
        enum.join()

    subdom = set(sub_inline)
    for subdomain in subdom:
        search_list.add(subdomain)

    if subdom:
        subdom = sorted(subdom, key=sort_sub)

        print("Subdomains: %s" % len(subdom))
        s_domainLen="Subdomains: %s" % len(subdom)


        for subdomain in subdom:
            print(subdomain)
    return find,s_domainLen,subdom



